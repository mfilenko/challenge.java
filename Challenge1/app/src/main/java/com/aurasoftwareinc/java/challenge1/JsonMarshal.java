package com.aurasoftwareinc.java.challenge1;

import org.json.JSONObject;
import org.json.JSONArray;

import java.lang.reflect.Field;
import java.lang.reflect.Array;

public class JsonMarshal
{
    /**
     * JSON marshaller.
     *
     * @param object object to marshal as JSON
     * @return       JSON object
     */
    public static JSONObject marshalJSON(Object object)
    {

        JSONObject json = new JSONObject();

        // TODO: defensive programming (e.g., null checks).
        try
        {
            // Iterate over object properties.
            for (Field field : object.getClass().getDeclaredFields())
            {
                // Turn off access checks for private fields (works only for reflection).
                if (!field.isAccessible())
                {
                    field.setAccessible(true);
                }

                String name = field.getName();
                Class<?> type = field.getType();
                Object value = field.get(object);

                // Skip fields generated by the runtime like `$change`, etc.
                if (field.isSynthetic())
                {
                    continue;
                }

                if (JsonMarshalInterface.class.isAssignableFrom(type))
                {
                    json.put(name, ((JsonMarshalInterface) value).marshalJSON());
                }
                else if (type.isArray())
                // TODO: in case array can nest something else than primitives this logic has to be
                //       extracted into a separate method so it can be called recursively.
                {
                    JSONArray jarr = new JSONArray();

                    for (int i = 0; i < Array.getLength(value); i++)
                    {
                        Object obj = Array.get(value, i);
                        jarr.put(obj);
                    }

                    json.put(name, jarr);
                }
                else
                {
                    json.put(name, value);
                }
            }
        }
        catch (Exception ignore)
        {
            ignore.printStackTrace();
        }

        return json;
    }

    /**
     * JSON unmarshaller.
     *
     * @param object Object to unmarshal to (receiver)
     * @param json   JSON to unmarshal (original object)
     * @return       <code>true</code> on successful unmarshalling;
     *               <code>false</code> otherwise.
     */
    public static boolean unmarshalJSON(Object object, JSONObject json)
    {
        // TODO: defensive programming (e.g., null checks).
        try
        {
            // Iterate over object properties.
            for (Field field : object.getClass().getDeclaredFields())
            {
                // Turn off access checks for private fields (works only for reflection).
                if (!field.isAccessible())
                {
                    field.setAccessible(true);
                }

                String name = field.getName();
                Class<?> type = field.getType();

                // Skip fields generated by the runtime like `$change`, etc.
                if (field.isSynthetic())
                {
                    continue;
                }

                if (!json.has(name))
                {
                    continue;
                }

                if (JsonMarshalInterface.class.isAssignableFrom(type))
                {
                    Object obj = type.newInstance();
                    ((JsonMarshalInterface) obj).unmarshalJSON((JSONObject) json.get(name));
                    field.set(object, obj);
                }
                else if (type.isArray())
                // TODO: in case array can nest something else than primitives this logic has to be
                //       extracted into a separate method so it can be called recursively.
                {
                    type = type.getComponentType();
                    JSONArray jarr = json.getJSONArray(name);
                    Object arr = Array.newInstance(type, name.length());

                    for (int i = 0; i < jarr.length(); i++)
                    {
                        Object jel = jarr.get(i);

                        if (JsonMarshalInterface.class.isAssignableFrom(type))
                        {
                            JsonMarshalInterface obj = (JsonMarshalInterface) type.newInstance();
                            obj.unmarshalJSON((JSONObject) jel);
                            Array.set(arr, i, jel);
                        }
                        else
                        {
                            Array.set(arr, i, jel);
                        }
                    }

                    field.set(object, arr);
                }
                else
                {
                    field.set(object, json.get(name));
                }
            }
        }
        catch (Exception ignore)
        {
            ignore.printStackTrace();
            return false;
        }

        return true;
    }
}